
#ifndef CACHE_IMPL
#define CACHE_IMPL

// template implementation included by Cache.h

#include <cassert>

const int NOT_A_LAYER = -1;

template <class LayerType> Cache<LayerType>::Cache(const std::string &basename)
{
    bool done = false;
    int i = 0;
    
    while (!done)
    {
        layers.push_back(LayerType(basename, i));
        
        if (layers[i].size() == 0)
        {
            layers.pop_back();    // lose the empty layer
            done = true;
        }
    }
}

template <class LayerType> int Cache<LayerType>::depth() const
{
    return layers.size() - 1;
}

template <class LayerType> int Cache<LayerType>::count(int deep)
{
    assert(deep >=0 && deep <= depth());

    return layers[deep].size();
}

template <class LayerType>  
//  
bool Cache<LayerType>::contains(const Cube &cube, int deep /* = -1 */) const
{
    if (deep < 0)
    {
        return (layer(cube) != NOT_A_LAYER);
    }
    else
    {
        assert(deep >=0 && deep <= depth());
        
        return layers[deep].contains(cube);
    }
}

template <class LayerType>
//    
int Cache<LayerType>::layer(const Cube &cube) const
{
    for (int i = depth(); i >= 0; --i)
    {
        if (layers[i].contains(cube))
        {
            return layers[i].depth();
        }
    }
    return NOT_A_LAYER;
}

template <class LayerType>
//
const LayerType& Cache<LayerType>::get_layer(const Cube &cube) const
{
    for (int i = depth(); i >= 0; --i)
    {
        if (layers[i].contains(cube))
        {
            return layers[i];
        }
    }
    assert(false);
    return layers[0];
}

#endif
