
#ifndef CACHEBUILDER_IMPL
#define CACHEBUILDER_IMPL

// template implementation included by CacheBuilder.h

#include <cassert>
#include <iostream>
#include <fstream>
#include <sstream>
#include "Cube.h"
#include "Scramble.h"

#define SAY(X) if (m_verbose) { std::cout << X << std::endl; }

const Cube::Twist noTwist;

extern bool cant_follow(int last, int next);

template <class LayerType>
//
CacheBuilder<LayerType>::CacheBuilder(const std::string &basename)
: m_basename(basename), m_verbose(false)
{
    // TODO check the directory part exists
}

template <class LayerType> void CacheBuilder<LayerType>::verbose(bool on)
{
    m_verbose = on;
}

template <class LayerType> bool CacheBuilder<LayerType>::verbose() const
{
    return m_verbose;
}

template <class LayerType>
//
bool CacheBuilder<LayerType>::seen_before(const Cube &cube)
{
    for (int i = m_layers.size() - 1; i >= 0; --i)
    {
        if (m_layers[i]->contains(cube))
            return true;
    }
    return false;
}

template <class LayerType> void CacheBuilder<LayerType>::new_layer(LayerType *layer)
{
    layer->initialise();
    
    long considered = 0;
    
    // iterate over the set of cube positions from the previous layer
    
    Cube previous_cube;
    Cube::Twist last_twist;
    
    while (layer->get_position(previous_cube, last_twist))
    {
        int last_face = (last_twist == noTwist) ? -1 : last_twist.getFace();
            
        for (int f = 0; f < 6; f++)
        {
            if (cant_follow(last_face, f))
                continue;
                    
            for (int t = 1; t <= 3; t++)
            {
                Cube::Twist next_twist((Cube::Face)f, t);
                
                Cube next_cube = previous_cube;
                next_cube.twist(next_twist);
                
                ++considered;
                
                if (!seen_before(next_cube))
                {
                    layer->add_position(next_cube, next_twist);
                }
            }
        }
    }
    SAY("New states considered " << considered);

    SAY("Finalising layer states...");
    int remaining = layer->finalise();
    
    SAY("Unique states found " << remaining);
}

template <class LayerType> LayerType* CacheBuilder<LayerType>::build_layer(int N)
{
    SAY("Looking for cache layer " << N);
    
    LayerType *layer = new LayerType(m_basename, N);
    
    if (layer->size() > 0)
    {
        SAY("Found it.");
    }
    else
    {
        SAY("Not found. Building it...");
        
        new_layer(layer);
    }
    return layer;
}

template <class LayerType> void CacheBuilder<LayerType>::build(int deep)
{
    long total = 0;
    
    for (int i = 0; i <= deep; i++)
    {
        // do not reload / rebuild layers we already have
        
        if (i == m_layers.size())
        {
            // do not add empty layers or try to build more after an empty one
            
            LayerType *layer = build_layer(i);
            
            if (layer->size() > 0)
            {
                m_layers.push_back(layer);
                
                SAY("Loaded layer " << i << " with " << layer->size() << " states.");
                total += layer->size();
            }
        }
    }
    SAY("Total number of states: " << total);
}

template <class LayerType>
//
void CacheBuilder<LayerType>::free()
{
    for (int i = 0; i < m_layers.size(); i++)
    {
        delete m_layers[i];
    }
    m_layers.clear();
}

#endif
