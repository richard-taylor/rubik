
#ifndef CACHEBUILDER_IMPL
#define CACHEBUILDER_IMPL

// template implementation included by CacheBuilder.h

#include <cassert>
#include <iostream>
#include <fstream>
#include <sstream>
#include <sys/stat.h>
#include "Cube.h"
#include "Scramble.h"

#define SAY(X) if (m_verbose) { std::cout << X << std::endl; }

const Cube::Twist noTwist;

extern bool cant_follow(int last, int next);

template <class LayerType>
//
CacheBuilder<LayerType>::CacheBuilder(const std::string &basename)
: m_basename(basename), m_verbose(false)
{
    // TODO check the directory part exists
}

template <class LayerType> void CacheBuilder<LayerType>::verbose(bool on)
{
    m_verbose = on;
}

template <class LayerType> bool CacheBuilder<LayerType>::verbose() const
{
    return m_verbose;
}

template <class LayerType>
//
std::string CacheBuilder<LayerType>::append(int N, const std::string &suffix)
{
    std::stringstream ss;
    ss << m_basename << "." << N;
    
    if (suffix != "")
    {
        ss << "." << suffix;
    }
    return ss.str();
}

template <class LayerType>
//
std::string CacheBuilder<LayerType>::cubefile(int N)
{
    return append(N, "cubes");
}

template <class LayerType>
//
bool CacheBuilder<LayerType>::seen_before(const Cube &cube)
{
    for (int i = m_layers.size() - 1; i >= 0; --i)
    {
        if (m_layers[i].contains(cube))
            return true;
    }
    return false;
}

template <class LayerType>
//
int CacheBuilder<LayerType>::build_layer(int N, const std::string &statefile)
{
    // first create the new state list with possible duplicates
    
    std::string state_max = append(N, "tmp.state");
    
    std::ofstream smax(state_max.c_str(), std::ios::binary);
    
    int considered = 0;
    int forwarded = 0;
    
    // iterate over the set of cubes from the previous layer
    
    std::ifstream cubes(cubefile(N - 1).c_str(), std::ios::binary);
    
    Cube cube;
    Cube::Twist twist = noTwist;
    
    while (LayerType::read_cube(cubes, cube, twist))
    {
        int lastFace = (twist == noTwist) ? -1 : twist.getFace();
            
        for (int f = 0; f < 6; f++)
        {
            if (cant_follow(lastFace, f))
                continue;
                    
            for (int t = 1; t <= 3; t++)
            {
                Cube::Twist next_twist((Cube::Face)f, t);
                
                Cube next_cube = cube;
                next_cube.twist(next_twist);
                
                ++considered;
                
                if (!seen_before(next_cube))
                {
                    ++forwarded;
                    
                    LayerType::write_cube(smax, next_cube, next_twist);
                }
            }
        }
    }
    SAY("New states (including duplicates) " << forwarded << " / " << considered);

    smax.close();
        
    SAY("Removing duplicate states...");
    int remaining = LayerType::squash_states(state_max, statefile, cubefile(N));
    SAY("Unique states found " << remaining);
    
    return remaining;
}

template <class LayerType> int CacheBuilder<LayerType>::build_layer(int N)
{
    std::string filename = append(N, "");
    
    SAY("Looking for cache layer " << filename);
    
    struct stat buffer;   
    if (stat(filename.c_str(), &buffer) == 0)
    {
        SAY("Found it.");
        return 1;
    }
    else
    {
        SAY("Not found. Building it...");
        
        if (N == 0)
        {
            // write the layer state to basename.N
            
            std::ofstream f1(filename.c_str(), std::ios::binary);

            LayerType::write_state(f1, Cube());
            
            // write the cube states to basename.N.cubes  
            
            std::ofstream f2(cubefile(N).c_str(), std::ios::binary);
            
            LayerType::write_cube(f2, Cube(), noTwist);
            
            // one state in this layer
            return 1;
        }
        else
        {
            return build_layer(N, filename);
        }
    }
}

template <class LayerType> void CacheBuilder<LayerType>::build(int deep)
{
    for (int i = 0; i <= deep; i++)
    {
        // do not reload / rebuild layers we already have
        
        if (i == m_layers.size())
        {
            // do not add empty layers or try to build more after an empty one
            
            if (build_layer(i) > 0)
            {
                m_layers.push_back(LayerType(m_basename, i));
                
                SAY("Loaded layer " << i << " with " << m_layers[i].size() << " states.");
            }
        }
    }
}

#endif
