
#ifndef CACHEBUILDER_IMPL
#define CACHEBUILDER_IMPL

// template implementation included by CacheBuilder.h

#include <cassert>
#include <iostream>
#include <fstream>
#include <sstream>
#include "Cube.h"
#include "Scramble.h"

#define SAY(X) if (m_verbose) { std::cout << X << std::endl; }

const Cube::Twist noTwist;

extern bool cant_follow(int last, int next);

template <class LayerType>
//
CacheBuilder<LayerType>::CacheBuilder(const std::string &basename)
: m_basename(basename), m_verbose(false)
{
    // TODO check the directory part exists
}

template <class LayerType> void CacheBuilder<LayerType>::verbose(bool on)
{
    m_verbose = on;
}

template <class LayerType> bool CacheBuilder<LayerType>::verbose() const
{
    return m_verbose;
}

template <class LayerType>
//
bool CacheBuilder<LayerType>::seen_before(const Cube &cube)
{
    for (int i = m_layers.size() - 1; i >= 0; --i)
    {
        if (m_layers[i].contains(cube))
            return true;
    }
    return false;
}

template <class LayerType>
//
int CacheBuilder<LayerType>::new_layer(int N)
{
    // first create the new state list with possible duplicates
    
    std::ofstream temp(LayerType::temp_file(m_basename, N).c_str(), std::ios::binary);
    
    int considered = 0;
    int forwarded = 0;
    
    // iterate over the set of cubes from the previous layer
    
    std::ifstream cubes(LayerType::cube_file(m_basename, N - 1).c_str(), std::ios::binary);
    
    typename LayerType::Position position;
    
    while (LayerType::read_position(cubes, position, N - 1))
    {
        Cube::Twist twist = position.lastTwist();

        int lastFace = (twist == noTwist) ? -1 : twist.getFace();
            
        for (int f = 0; f < 6; f++)
        {
            if (cant_follow(lastFace, f))
                continue;
                    
            for (int t = 1; t <= 3; t++)
            {
                Cube::Twist next_twist((Cube::Face)f, t);
                
                Cube next_cube = position.cube();
                next_cube.twist(next_twist);
                
                ++considered;
                
                if (!seen_before(next_cube))
                {
                    ++forwarded;
                    
                    LayerType::write_position(temp, position, next_cube, next_twist);
                }
            }
        }
    }
    SAY("New states (including duplicates) " << forwarded << " / " << considered);

    temp.close();
        
    SAY("Removing duplicate states...");
    int remaining = LayerType::squash_temp(m_basename, N);
    SAY("Unique states found " << remaining);
    
    return remaining;
}

template <class LayerType> int CacheBuilder<LayerType>::build_layer(int N)
{
    SAY("Looking for cache layer " << N);
    
    if (LayerType::exists(m_basename, N))
    {
        SAY("Found it.");
        return 1;
    }
    else
    {
        SAY("Not found. Building it...");
        
        if (N == 0)
        {
            return LayerType::make_first_layer(m_basename);
        }
        else
        {
            return new_layer(N);
        }
    }
}

template <class LayerType> void CacheBuilder<LayerType>::build(int deep)
{
    for (int i = 0; i <= deep; i++)
    {
        // do not reload / rebuild layers we already have
        
        if (i == m_layers.size())
        {
            // do not add empty layers or try to build more after an empty one
            
            if (build_layer(i) > 0)
            {
                m_layers.push_back(LayerType(m_basename, i));
                
                SAY("Loaded layer " << i << " with " << m_layers[i].size() << " states.");
            }
        }
    }
}

#endif
